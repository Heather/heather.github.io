<?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE html><html ng-app><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="Heather" name="description"><meta content="width=device-width, initial-scale=1.0" name="viewport"><link href="../atom.xml" title="Heather" type="application/atom+xml" rel="alternate"><link href="../favicon.ico" type="image/ico" rel="shortcut icon"><script src="../bootstrap/jquery-2.1.1.min.js"></script><link href="../bootstrap/bootstrap.min.css" rel="stylesheet"><link href="../bootstrap/bootstrap-theme.min.css" rel="stylesheet"><script src="../bootstrap/bootstrap.min.js"></script><script src="../bootstrap/angular.min.js"></script><link href="../css/hasklig.css" media="all" type="text/css" rel="stylesheet"><link href="../css/octicons.css" media="all" type="text/css" rel="stylesheet"><link href="../css/syntax.css" media="all" type="text/css" rel="stylesheet"><link href="../css/default.css" media="all" type="text/css" rel="stylesheet"><title>Heather - Selling dependent types</title><script src="../js/auto.js"></script></head><body><div class="band"></div><div id="header"><div id="logo"><a href="../" id="abbr"></a><script>e = document.getElementById("abbr");setTimeout(r, 0);</script></div></div><div id="content"><h1>Selling dependent types</h1><audio autoplay loop id="audio"><source src="../images/Bween.mp3" type="audio/mp3"></audio><div id="controls"><img height="20px" width="20px" src="../images/RedPause.png" id="playpause"></div><div class="info">Posted on 27 March 2015</div><p>There was long standing question on <a href="https://twitter.com/lenadroid/status/577058060860071937">Twitter</a></p>
<h1 id="practical-applicationuse-cases-of-dependently-typed-programming-languages">practical application/use cases of dependently typed programming languages?</h1>
<p>Edwin Brady:</p>
<blockquote>
<p>My current favourite phrase is “making assumptions explicit” - if you assume something, tell the type checker! [1/2] <br /> e.g. in non DT code I might assume a list can’t be empty, but it’s hard to make that explicit and it bites later [2/2] <br /> This kind of lightweight property may be more valuable than the strong correctness proofs we like to show off with [3/2] <br /> Seems I violated an assumption… [4/4]</p>
</blockquote>
<p>Great answer from Chris Allen:</p>
<blockquote>
<p>in Haskell values can generate values, types can generate values, values <em>cannot</em> generate types. <br /> That sucks and means there’s a bunch of things you’re not allowed to do. There’s a phase separation between types and values. <br /> in Idris, types and values can hop back and forth interchangeably, almost kinda like if you had reflection, except it’s type-safe and used to create types that very precisely circumscribe what you want. <br /> puffnfresh’s printf tutorial is a good example of this. <br /> there ways to avoid needing dependent types in Haskell, but most people would like the option. <br /> it simplifies things related to writing very precisely typed software <br /> it makes writing more type-safe software less troublesome. <br /> it also often means you can more readily use the language as a sort of proof engine. <br /> I’ve seen people do this in Haskell, but it’s far more common in Coq, Agda, etc. <br /> virtually everything could use more type-safety. <br /> something as common as printf benefits from dependent types. <br /> imagine being able to take the requirements of business logic, which are usually enforced at runtime, and turn them into a proof? <br /> now your programs can’t violate the contracts you want to enforce.</p>
</blockquote>
<p>Answer from Brian McKenna:</p>
<blockquote>
<p>yeah, proofs as programs, one useful thing <br /> another is safe metaprogramming <br /> e.g. string interpolation, custom literals <br /> one example I’ve been interested in recently is putting Big-O complexity into types <br /> so proving some performance characteristics of algorithms</p>
</blockquote>
<p>(I should also post link to this <a href="https://gist.github.com/puffnfresh/11202637">printf</a>)</p>
<p>I was asked to post my simple explanation so here is it…</p>
<p>For example everybody knows about generics and why and where they are useful and we call it alike <code>foo&lt;Type&gt;()</code>, now imagine we have some function which does something and returns Type based on integer, for example 4 -&gt; Int, 2 -&gt; Short, 8 -&gt; Long, etc… So we can <code>foo&lt;bar(i)&gt;()</code> so in this case you will not create additional case type-binder… e.g. you still write that 4 will be Int but you don’t write that 4 will be foo<int> … that looks like small metaprogramming trick but when it’s all over the code it’s not bad, e.g. better readability and more available programming tactics for logics implementation, faster solution solving</p>
<p>Let take a look to example on <a href="http://www.rust-lang.org">rust-lang.org</a></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">let program = <span class="st">&quot;+ + * - /&quot;</span>;
let mut accumulator = <span class="dv">0</span>;

<span class="kw">for</span> token in program.chars() {
    match token {
        <span class="st">'+'</span> =&gt; accumulator += <span class="dv">1</span>,
        <span class="st">'-'</span> =&gt; accumulator -= <span class="dv">1</span>,
        <span class="st">'*'</span> =&gt; accumulator *= <span class="dv">2</span>,
        <span class="st">'/'</span> =&gt; accumulator /= <span class="dv">2</span>,
        _ =&gt; { <span class="co">/* ignore everything else */</span> }
    }
}</code></pre></div>
<p>(note that line <code>'/' =&gt; accumulator /= 2</code> looks a bit different due my fonts there, it’s just <code>/</code> and <code>=</code> together…)</p>
<p>Press <code>Run</code> on website</p>
<p>Not sure if you guess or not but result is 1, because it’s integer…</p>
<p>How we can handle it with Idris?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;The program &quot;</span>
                    ⧺ prog
                    ⧺ <span class="st">&quot; calculates the value &quot;</span>
                    ⧺ (show <span class="fu">$</span> acc (unpack prog) <span class="dv">0</span>)
 <span class="kw">where</span> aType <span class="fu">:</span> <span class="dt">Type</span>
       aType <span class="fu">=</span> <span class="kw">if</span> (<span class="ch">'/'</span> ∈ (unpack prog))
                    <span class="kw">then</span> <span class="dt">Float</span>
                    <span class="kw">else</span> <span class="dt">Int</span>

       acc <span class="fu">:</span> (<span class="dt">List</span> <span class="dt">Char</span>) <span class="ot">→</span> aType <span class="ot">→</span> aType
       acc [] m <span class="fu">=</span> m
       acc (<span class="ot">x::</span>xs) m <span class="fu">=</span> acc xs <span class="fu">$</span> <span class="kw">case</span> x <span class="kw">of</span>
                                 <span class="ch">'+'</span> <span class="ot">=&gt;</span> m <span class="fu">+</span> <span class="dv">1</span>
                                 <span class="ch">'-'</span> <span class="ot">=&gt;</span> m <span class="fu">-</span> <span class="dv">1</span>
                                 <span class="ch">'*'</span> <span class="ot">=&gt;</span> m ⋅ <span class="dv">2</span>
                                 <span class="ch">'/'</span> <span class="ot">=&gt;</span> m ÷ <span class="dv">2</span>
                                 _   <span class="ot">=&gt;</span> m</code></pre></div>
<pre class="shell"><code>The program + + * - / calculates the value 1.5</code></pre>
<p>Discover the difference… But it’s small case. With thinking about types we can resolve a lot of common problems much faster. One of the great examples will be type providers in Idris <a href="https://github.com/david-christiansen/idris-type-providers">github</a> <a href="http://itu.dk/people/drc/pubs/dependent-type-providers.pdf">pdf</a> by David Christiansen</p><div id="postfooter"></div><script src="../js/playpause.js"></script><script src="../bootstrap/three.js"></script><script src="../js/bubbles.js"></script></div><div id="social"><ul><li><a href="http://twitter.com/Cynede" title="Twitter" target="_blank"><span class="mega-octicon octicon-star"></span></a></li><li><a href="mailto:heather@live.ru" title="mail" target="_blank"><span class="mega-octicon octicon-mail-read"></span></a></li><li><a href="http://www.last.fm/user/Cynede" title="Last.fm" target="_blank"><span class="mega-octicon octicon-broadcast"></span></a></li><li><a href="http://stackoverflow.com/users/238232/heather" title="Stackoverflow" target="_blank"><span class="mega-octicon octicon-squirrel"></span></a></li><li><a href="../atom.xml" title="RSS" target="_blank"><span class="mega-octicon octicon-rss"></span></a></li></ul></div><div id="footer"></div></body></html>