<?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE html><html ng-app><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="Heather" name="description"><meta content="width=device-width, initial-scale=1.0" name="viewport"><link href="../atom.xml" title="Heather" type="application/atom+xml" rel="alternate"><link href="../favicon.ico" type="image/ico" rel="shortcut icon"><script src="../bootstrap/jquery-2.1.1.min.js"></script><link href="../bootstrap/bootstrap.min.css" rel="stylesheet"><link href="../bootstrap/bootstrap-theme.min.css" rel="stylesheet"><script src="../bootstrap/bootstrap.min.js"></script><script src="../bootstrap/angular.min.js"></script><link href="../css/hasklig.css" media="all" type="text/css" rel="stylesheet"><link href="../css/octicons.css" media="all" type="text/css" rel="stylesheet"><link href="../css/syntax.css" media="all" type="text/css" rel="stylesheet"><link href="../css/default.css" media="all" type="text/css" rel="stylesheet"><title>Heather - Haskell disorder</title><script src="../js/auto.js"></script></head><body><div class="band"></div><div id="header"><div id="logo"><a href="../" id="abbr"></a><script>e = document.getElementById("abbr");setTimeout(r, 0);</script></div></div><div id="content"><h1>Haskell disorder</h1><audio autoplay loop id="audio"><source src="../images/Bween.mp3" type="audio/mp3"></audio><div id="controls"><img height="20px" width="20px" src="../images/RedPause.png" id="playpause"></div><div class="info">Posted on 16 January 2016</div><p>Many different people have different opinions of what language ecosystem should be. Many people don’t care. Some people don’t care and have opinion in the same time. How is that? Simply they are able to build their project and run it using their tool. They don’t need other changes. They just want to be safe in their (sometimes very specific) workflow. And that could be even named alike “time-tested strategies that are known to work (like known-good package sets)”. There are could be different reasoning but mostly people tell that they care. People care about their own workflow. Sometimes we just need to point that they are not alone. When you say that something is distro-specific, os-specific, language-specific, workflow-specific you just face the limitation and limitation is something most people would like to avoid.</p>
<blockquote>
<p>Haskell programs and libraries extensively reuse entitites (types, functions, rewrite rules, type instances, other stuff) exported from external libraries as non-opaque entities to allow aggressive cross-module inlining to compile away deep layers of abstraction. It’s language’s feature. If you accept the fact transitive dependencies being able to break ABI is not a GHC bug</p>
</blockquote>
<blockquote>
<p>what actually affects real ABI (exported inlines, exported datatype layout changes, modules names, strictness annotations, unpack pragmas) ghc –show-iface can help in tracking ABI drift.</p>
</blockquote>
<p>I’ve seen that people tell that <code>stack</code> and <code>cabal</code> are much better than <code>pip</code> for example</p>
<p>However when you install library or executable <code>A</code> whcih is depending on <code>B</code> it’s likely already dangerous Because when we have libraries that have had their dependencies changed it’s likely broken (in case of changed ABI) And neither <code>stack</code> neither <code>cabal</code> can help you with your broken environment Neither <code>python</code> ever used to had this problem That could be work for some <code>package manager</code> and could be called <code>revdep-rebuild</code> (scan libs for missing shared library dependencies and attempts to fix them by rebuilding broken libs) That’s how you manage dynamic libraries updating on system level</p>
<p>From what I see currently stack is something unmanaged, I can’t update some root library used for system binaries</p>
<p>There are known problems which developers regularry face with cabal-install and stack brings easier and safer workflow for developers, that’s true. But I don’t see how stack can help developers to understand other aspects</p>
<p>When haskellers talk about user installation they really mean sandbox When haskellers talk about global installation they mean user installation When haskellers talk about system installation their brains blows</p>
<p>People complain that on Haskell.org there is harmful workflow for developers introducing Haskell Platform and it should be overtaken by stack. (Note that Haskell Platform is system installation used by different users and it can’t be messed up with user installation)</p>
<p>However either <code>cabal-install</code> and <code>stack</code> worklows are both harmful for users, <code>stack</code> does resolve nothing for user side, it just helps you with sandbox managing during development stage.</p>
<p>I will try to explain.</p>
<p>Regularly users use package managers (on windows installers) to get what they want, that’s how users install python projects, C++ projects, etc… users don’t use pip (really they don’t)</p>
<p>What about haskell? On most distributions and Windows users should use what? sandboxes for every program and install those progam for every users avoiding system installation?</p>
<p>Currently yes. Other ways will be harmful. There is solution from NixOS but I doubt if they’ve managed to implement revdep rebuild for haskell packages. I like (a lot) solution from gentoo where you can simply run <code>emerge idris</code> and everything will be installed on system alike you install some python util (alike portage itself). But even in Gentoo there is dirty hack to manage haskell packages updates.</p>
<p>it looks really dirty</p>
<pre class="shell"><code>    haskell-updater -- --jobs=&quot;$(($(nproc) + 1))&quot; --verbose-conflicts
--backtrack=100
    haskell-updater -- --jobs=&quot;$(($(nproc) + 1))&quot; --verbose-conflicts
--backtrack=100</code></pre>
<p>basically it’s rebuilding all libs depending on changed one then depending on depending incrementally</p>
<p>What is it even?</p>
<p>Haskell programs and libraries extensively reuse entitites (types, functions, rewrite rules, type instances, other stuff) exported from external libraries as non-opaque entities to allow aggressive cross-module inlining to compile away deep layers of abstraction. It’s language’s feature. If you accept the fact transitive dependencies being able to break ABI is not a GHC bug</p>
<p>what actually affects real ABI (exported inlines, exported datatype layout changes, modules names, strictness annotations, unpack pragmas) ghc –show-iface can help in tracking ABI drift.</p>
<p>So in nutshell it’s a feature but when we’re fixing linkage for C/C++ we can scan libs for missing shared library dependencies and attempts to fix them by rebuilding broken libs For haskell we hardly can detect ABI changes and the only way I know currently is <code>haskell-updater</code> util and I’m still looking for better solution</p>
<p>For example when one project, for example Idris, start using changed (bumped) library which is shipped with GHC it feels absolutely fine on sandbox But when user will install idris (and that library to system) all other libraries will become broken because their dependencies is changed by that That’s why some core packages has -compat compatibility layers Sure developers tell me that they don’t care and everything works fine in sandboxes and downgrading this library is distro-patch</p>
<p>Note that currently either cabal-install and stack has nothing to do with atomic packages managing. Package manager can install, can remove, can update, can track dependies changes and end with working environment without sandbox replacing. Honestly it’s very same situation with python or perl with only difference… When I install software written on python I don’t need to use <code>pip</code> and <code>Haskell</code> seems like much harder to package but people everywhere only force you to use really wrong solutions (including community loved stack)</p>
<p>So my question is generally to community: are we even going to think in direction of users or are we just focus on developers and their sandboxes? In second case we need docker for each Haskell project.</p><div id="postfooter"></div><script src="../js/playpause.js"></script><script src="../bootstrap/three.js"></script><script src="../js/bubbles.js"></script></div><div id="social"><ul><li><a href="http://github.com/Heather" title="Github" target="_blank"><span class="mega-octicon octicon-octoface"></span></a></li><li><a href="http://twitter.com/Cynede" title="Twitter" target="_blank"><span class="mega-octicon octicon-star"></span></a></li><li><a href="mailto:heather@live.ru" title="mail" target="_blank"><span class="mega-octicon octicon-mail-read"></span></a></li><li><a href="http://www.last.fm/user/Cynede" title="Last.fm" target="_blank"><span class="mega-octicon octicon-broadcast"></span></a></li><li><a href="http://stackoverflow.com/users/238232/heather" title="Stackoverflow" target="_blank"><span class="mega-octicon octicon-squirrel"></span></a></li><li><a href="../atom.xml" title="RSS" target="_blank"><span class="mega-octicon octicon-rss"></span></a></li></ul></div><div id="footer"></div></body></html>